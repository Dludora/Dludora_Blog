<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Dludora's Blog</title><link>https://Dludora.github.io/Dludora_Blog/</link><description>Recent content on Dludora's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 30 Jun 2022 11:42:08 +0800</lastBuildDate><atom:link href="https://Dludora.github.io/Dludora_Blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Java IO流</title><link>https://Dludora.github.io/Dludora_Blog/java/io/</link><pubDate>Thu, 30 Jun 2022 11:42:08 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/java/io/</guid><description>Java IO 流 一、文件操作 1、创建文件 new File(String pathname) 根据路径构建一个File对象
new File(File parent, String child) 根据父目录文件+子路径构造
new File(String parent, String child) 根据父目录+子路径构建
创建文件对象后,执行 file.createNewFile
2、获取文件信息 file.getName()文件名字
file.getAbsolutePath()文件绝对路径
file.getParent文件父级目录
file.length()文件大小(字节)
file.exists() 文件/目录是否存在
file.isFile()是否是文件
file.isDirectory()是否是目录
3、目录操作 file.delete() 删除文件/目录
file.mkdir() 创建一级目录
file.mkdirs() 创建多级目录
二、Java IO流原理及其分类 ​ I/O是input/output的缩写，按照操作数据单位不同分为字节流，字符流。字节流操作二进制文件时更加适合，字符流操作文本文件更加适合。按照流的角色分为节点流、处理流/包装流。
​ IO流使用完毕后必须关闭!
抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 节点流是从某一个特定的数据源读写数据，如FileReader、FileWriter。处理流是包装节点流，可以消除不同节点流的实现差异，以更加方便的方法实现输入输出，使用了修饰器设计模式，不会直接与数据源相连，如BufferedReader、BufferedWriter。
1、InputStream 1.1 BufferedInputStream 缓冲字节流 1.2 FileInputStream 文件字节流 构造方法：
FIleInputStream(File file) FIleInputStream(String filePath) FIleInputStream(FileDescription fdObj) 方法</description></item><item><title>Vue解决登录问题</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/my-third-post/</link><pubDate>Sat, 04 Jun 2022 17:00:03 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/my-third-post/</guid><description>Token 将token存储到store中，在store文件夹下新建user.js
命令行输入npm i js-cookie</description></item><item><title>Vue 与 Markdown 交互</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/my-second-post/</link><pubDate>Thu, 02 Jun 2022 23:11:47 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/my-second-post/</guid><description>Vue 与 Markdown 交互 1. vue3 适配的 markdown编辑器 ​ 命令行输入npm i @kangc/v-md-editor@next -S安装 v-md-editor组件
​ 在main.js中加入如下代码，即可通过v-md-editor模块进行使用markdown编辑器
// 引入所有语言包 import hljs from &amp;#39;highlight.js&amp;#39; import VMdPreview from &amp;#39;@kangc/v-md-editor/lib/preview&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/style/preview.css&amp;#39;; import VMdEditor from &amp;#39;@kangc/v-md-editor/lib/codemirror-editor&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/style/codemirror-editor.css&amp;#39;; import githubTheme from &amp;#39;@kangc/v-md-editor/lib/theme/github.js&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/theme/style/github.css&amp;#39;; // emoji import createEmojiPlugin from &amp;#39;@kangc/v-md-editor/lib/plugins/emoji/index&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/plugins/emoji/emoji.css&amp;#39;; // 显示代码行数 import createLineNumbertPlugin from &amp;#39;@kangc/v-md-editor/lib/plugins/line-number/index&amp;#39;; // 快速复制 import createCopyCodePlugin from &amp;#39;@kangc/v-md-editor/lib/plugins/copy-code/index&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/plugins/copy-code/copy-code.css&amp;#39;; // codemirror 编辑器的相关资源 import Codemirror from &amp;#39;codemirror&amp;#39;; // mode import &amp;#39;codemirror/mode/markdown/markdown&amp;#39;; import &amp;#39;codemirror/mode/javascript/javascript&amp;#39;; import &amp;#39;codemirror/mode/css/css&amp;#39;; import &amp;#39;codemirror/mode/htmlmixed/htmlmixed&amp;#39;; import &amp;#39;codemirror/mode/vue/vue&amp;#39;; // edit import &amp;#39;codemirror/addon/edit/closebrackets&amp;#39;; import &amp;#39;codemirror/addon/edit/closetag&amp;#39;; import &amp;#39;codemirror/addon/edit/matchbrackets&amp;#39;; // placeholder import &amp;#39;codemirror/addon/display/placeholder&amp;#39;; // active-line import &amp;#39;codemirror/addon/selection/active-line&amp;#39;; // scrollbar import &amp;#39;codemirror/addon/scroll/simplescrollbars&amp;#39;; import &amp;#39;codemirror/addon/scroll/simplescrollbars.</description></item><item><title>前端跨域</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F/</link><pubDate>Mon, 16 May 2022 20:36:33 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F/</guid><description>Vue-Django解决跨域 什么是跨域 跨域本质是浏览器基于同源策略的一种安全手段
同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能
所谓同源（即指在同一个域）具有以下三个相同点
协议相同（protocol） 主机相同（host） 端口相同（port） 反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域
一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
配置vue.config.js实现跨域 原理 ​ 将域名发送给本地的服务器(localhost:8080) ​ 再由本地的服务器去请求真正的服务器 ​ 因为请求是从服务器端发出的，所以就不存在跨域的问题 实现步骤 安装并引入axios 前端终端中输出 npm install axios -s安装axios
在main.js中引入axios，在全局进行注册
import axios from &amp;#39;axios&amp;#39; app.config.globalProperties.$axios = axios 配置vue.config.js文件, 加入
devServer: { proxy:{ // 当我们的本地的请求 有/api的时候，就会代理我们的请求地址向另外一个服务器发出请求 // 这里的api 表示如果我们的请求地址有/api的时候,就出触发代理机制 // localhost:8888/api/abc =&amp;gt; 代理给另一个服务器 &amp;#39;/api&amp;#39;:{ // 目标路径,一般是后台服务器地址 target:&amp;#39;http://127.0.0.1:8000/&amp;#39;, // 允许跨域 changeOrigin: true, // 重写路径 pathRewrite: { // 重写路由 localhost:8888/api/login =&amp;gt; www.baidu.com/api/login &amp;#39;^/api&amp;#39;: &amp;#39;&amp;#39; // 假设我们想把 localhost:8888/api/login 变成www.</description></item><item><title>Vue_basic1</title><link>https://Dludora.github.io/Dludora_Blog/vue/vue_basic1/</link><pubDate>Fri, 13 May 2022 17:38:07 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/vue/vue_basic1/</guid><description/></item><item><title>Animation1</title><link>https://Dludora.github.io/Dludora_Blog/vue/animation1/</link><pubDate>Thu, 12 May 2022 20:34:40 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/vue/animation1/</guid><description>第三方库</description></item><item><title>Mysecond Post</title><link>https://Dludora.github.io/Dludora_Blog/mysql/mysecond-post/</link><pubDate>Tue, 10 May 2022 11:33:45 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/mysql/mysecond-post/</guid><description>煞笔！</description></item><item><title>前后端分离1</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/myfirst-post/</link><pubDate>Tue, 10 May 2022 11:08:11 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/myfirst-post/</guid><description>1、前后端项目合并 后端项目 项目创建/运行 ​ 在前端项目同级命令行中打开终端，输入django-admin startproject 项目名称
​ cd进该目录，输入 python manage.py runserver，运行该项目，终端上出现链接
配置数据库 ​ 找到第一次创建出的文件夹下，找到settings.py文件，找到如下代码
DATABASES = { &amp;#39;default&amp;#39;: { &amp;#39;ENGINE&amp;#39;: &amp;#39;django.db.backends.sqlite3&amp;#39;, &amp;#39;NAME&amp;#39;: BASE_DIR / &amp;#39;db.sqlite3&amp;#39;, } } ​ 如果想要更换为自己的mysql数据库，可以参考以下设置进行更改
DATABASES = { &amp;#39;default&amp;#39;: { &amp;#39;ENGINE&amp;#39;: &amp;#39;django.db.backends.mysql&amp;#39;, &amp;#39;NAME&amp;#39;: &amp;#39;xxx&amp;#39;, # 数据库名称 &amp;#39;USER&amp;#39;: &amp;#39;root&amp;#39; # 连接数据库的用户名称 &amp;#39;PASSWORD&amp;#39;: &amp;#39;xxxx&amp;#39; # 用户密码 &amp;#39;HOST&amp;#39;: &amp;#39;127.0.0.1&amp;#39; # 访问的数据库的主机ip地址 &amp;#39;PORT&amp;#39;: &amp;#39;3306&amp;#39; # 默认mysql访问端口 } } 运行 python manage.py migrate
新建应用 ​ 再次在终端上输入python manage.py startapp xxx，创建出xxx应用
​ 找到第一次创建出的文件夹下，找到settings.</description></item><item><title>Archive</title><link>https://Dludora.github.io/Dludora_Blog/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Dludora.github.io/Dludora_Blog/archive/</guid><description>archive</description></item></channel></rss>