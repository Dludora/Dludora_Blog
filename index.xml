<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Dludora's Blog</title><link>https://Dludora.github.io/Dludora_Blog/</link><description>Recent content on Dludora's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 03 Jul 2022 13:03:53 +0800</lastBuildDate><atom:link href="https://Dludora.github.io/Dludora_Blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Http协议</title><link>https://Dludora.github.io/Dludora_Blog/frontend/http%E5%8D%8F%E8%AE%AE/</link><pubDate>Sun, 03 Jul 2022 13:03:53 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/frontend/http%E5%8D%8F%E8%AE%AE/</guid><description>Http协议 Http协议是Hyper Text Transfer Protocol(超文本传输协议)的缩写，是从万维网www服务器传输超文本到本地浏览器的传输协议
HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。
主要特点 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 支持B/S及C/S模式。 URL HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息
URL,全称是Uniform Resource Locator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：
http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;amp;ID=24618&amp;amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分： 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&amp;quot;HTTP&amp;quot;后面的“//”为分隔符
域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;amp;ID=24618&amp;amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;amp;”作为分隔符。 URI和URL URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。 Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
URI一般由三部组成：
访问资源的命名机制 存放资源的主机名 资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
协议(或称为服务方式)
存有该资源的主机IP地址(有时也包括端口号)
主机资源的具体地址。如目录和文件名等
HTTP之请求消息Request 客户端发送一个HTTP请求到服务器的请求消息包括以下格式：
请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.</description></item><item><title>多用户即时通信系统</title><link>https://Dludora.github.io/Dludora_Blog/java/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/</link><pubDate>Fri, 01 Jul 2022 20:29:28 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/java/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>Socket</title><link>https://Dludora.github.io/Dludora_Blog/java/socket/</link><pubDate>Fri, 01 Jul 2022 16:27:37 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/java/socket/</guid><description>网络多线程 一、网络 1、相关概念 1.1 ip地址： 概念：用于唯一标识网络中的每台计算机/主机。 查看ip地址：ipconfig ip地址的表示形式：点分十进制 xx.xx.xx.xx 每一个ip地址的组成=网络地址+主机地址，如：192.168.16.69 IPV4：4个字节，IPV6：16个字节 ![image-20220701165216171](D:\My Blog\Dludora_Blog\content\Java\image-20220701165216171.png)
1.2 域名 把ip地址映射成域名，ping 域名来获取对应ip
二、Socket 通信的两端都要有Socket，是两台机器间通信的端点 网络通信其实就是Socket间的通信 Socket允许程序把网络连接党曾一个流，数据在两个Socket之间通过IO传输。 一般主动发起通信的应用程序是客户端，等待通信请求的是服务端。 ![image-20220701171039264](D:\My Blog\Dludora_Blog\content\Java\image-20220701171039264.png)
![image-20220701171246279](D:\My Blog\Dludora_Blog\content\Java\image-20220701171246279.png)
![image-20220701202741081](D:\My Blog\Dludora_Blog\content\Java\image-20220701202741081.png)</description></item><item><title>多线程</title><link>https://Dludora.github.io/Dludora_Blog/java/thread/</link><pubDate>Thu, 30 Jun 2022 20:38:02 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/java/thread/</guid><description>多线程 程序：我们写的代码 进程：运行中的程序，是程序的一个执行过程 一、继承Thread类（重写 run 方法） ​ 当一个类继承了Thread类，该类就可以当作线程使用。我们会重写run方法，写上自己的业务代码。run Thread类实现了Runnable接口中的run方法。通过start方法启动线程。
​ 使用JConsole监控线程执行情况，并画出程序示意图。(命令行输入jconsole)
public class Thread01 { public static void main(String[] args) throws InterruptedException { // 创建Cat对象，可以当作线程使用 Cat cat = new Cat(); cat.start(); // 启动线程-&amp;gt;最终会执行cat的run方法 // 当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行 System.out.println(&amp;#34;主线程继续执行&amp;#34; + Thread.currentThread().getName()); for (int i = 0; i &amp;lt; 10; i++) { System.out.println(&amp;#34;主线程 i = &amp;#34;+ i); // 让主线程休眠 Thread.sleep(1000); } } } class Cat extends Thread { int times = 0; @Override public void run() { while (true) { // 该线程每隔一秒，在控制台输出&amp;#34;喵喵，我是小猫咪&amp;#34; System.</description></item><item><title>Java IO流</title><link>https://Dludora.github.io/Dludora_Blog/java/io/</link><pubDate>Thu, 30 Jun 2022 11:42:08 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/java/io/</guid><description>Java IO 流 一、文件操作 1、创建文件 new File(String pathname) 根据路径构建一个File对象
new File(File parent, String child) 根据父目录文件+子路径构造
new File(String parent, String child) 根据父目录+子路径构建
创建文件对象后,执行 file.createNewFile
2、获取文件信息 file.getName()文件名字
file.getAbsolutePath()文件绝对路径
file.getParent文件父级目录
file.length()文件大小(字节)
file.exists() 文件/目录是否存在
file.isFile()是否是文件
file.isDirectory()是否是目录
3、目录操作 file.delete() 删除文件/目录
file.mkdir() 创建一级目录
file.mkdirs() 创建多级目录
二、Java IO流原理及其分类 ​ I/O是input/output的缩写，按照操作数据单位不同分为字节流，字符流。字节流操作二进制文件时更加适合，字符流操作文本文件更加适合。按照流的角色分为节点流、处理流/包装流。
​ IO流使用完毕后必须关闭!
抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 节点流是从某一个特定的数据源读写数据，如FileReader、FileWriter。处理流是包装节点流，可以消除不同节点流的实现差异，以更加方便的方法实现输入输出，使用了修饰器设计模式，不会直接与数据源相连，如BufferedReader、BufferedWriter。
1、InputStream 1.1 BufferedInputStream 缓冲字节流 1.2 FileInputStream 文件字节流 构造方法：
FIleInputStream(File file) FIleInputStream(String filePath) FIleInputStream(FileDescription fdObj) 方法</description></item><item><title>Vue解决登录问题</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/my-third-post/</link><pubDate>Sat, 04 Jun 2022 17:00:03 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/my-third-post/</guid><description>Token 将token存储到store中，在store文件夹下新建user.js
命令行输入npm i js-cookie</description></item><item><title>Vue 与 Markdown 交互</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/my-second-post/</link><pubDate>Thu, 02 Jun 2022 23:11:47 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/my-second-post/</guid><description>Vue 与 Markdown 交互 1. vue3 适配的 markdown编辑器 ​ 命令行输入npm i @kangc/v-md-editor@next -S安装 v-md-editor组件
​ 在main.js中加入如下代码，即可通过v-md-editor模块进行使用markdown编辑器
// 引入所有语言包 import hljs from &amp;#39;highlight.js&amp;#39; import VMdPreview from &amp;#39;@kangc/v-md-editor/lib/preview&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/style/preview.css&amp;#39;; import VMdEditor from &amp;#39;@kangc/v-md-editor/lib/codemirror-editor&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/style/codemirror-editor.css&amp;#39;; import githubTheme from &amp;#39;@kangc/v-md-editor/lib/theme/github.js&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/theme/style/github.css&amp;#39;; // emoji import createEmojiPlugin from &amp;#39;@kangc/v-md-editor/lib/plugins/emoji/index&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/plugins/emoji/emoji.css&amp;#39;; // 显示代码行数 import createLineNumbertPlugin from &amp;#39;@kangc/v-md-editor/lib/plugins/line-number/index&amp;#39;; // 快速复制 import createCopyCodePlugin from &amp;#39;@kangc/v-md-editor/lib/plugins/copy-code/index&amp;#39;; import &amp;#39;@kangc/v-md-editor/lib/plugins/copy-code/copy-code.css&amp;#39;; // codemirror 编辑器的相关资源 import Codemirror from &amp;#39;codemirror&amp;#39;; // mode import &amp;#39;codemirror/mode/markdown/markdown&amp;#39;; import &amp;#39;codemirror/mode/javascript/javascript&amp;#39;; import &amp;#39;codemirror/mode/css/css&amp;#39;; import &amp;#39;codemirror/mode/htmlmixed/htmlmixed&amp;#39;; import &amp;#39;codemirror/mode/vue/vue&amp;#39;; // edit import &amp;#39;codemirror/addon/edit/closebrackets&amp;#39;; import &amp;#39;codemirror/addon/edit/closetag&amp;#39;; import &amp;#39;codemirror/addon/edit/matchbrackets&amp;#39;; // placeholder import &amp;#39;codemirror/addon/display/placeholder&amp;#39;; // active-line import &amp;#39;codemirror/addon/selection/active-line&amp;#39;; // scrollbar import &amp;#39;codemirror/addon/scroll/simplescrollbars&amp;#39;; import &amp;#39;codemirror/addon/scroll/simplescrollbars.</description></item><item><title>前端跨域</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F/</link><pubDate>Mon, 16 May 2022 20:36:33 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F/</guid><description>Vue-Django解决跨域 什么是跨域 跨域本质是浏览器基于同源策略的一种安全手段
同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能
所谓同源（即指在同一个域）具有以下三个相同点
协议相同（protocol） 主机相同（host） 端口相同（port） 反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域
一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
配置vue.config.js实现跨域 原理 ​ 将域名发送给本地的服务器(localhost:8080) ​ 再由本地的服务器去请求真正的服务器 ​ 因为请求是从服务器端发出的，所以就不存在跨域的问题 实现步骤 安装并引入axios 前端终端中输出 npm install axios -s安装axios
在main.js中引入axios，在全局进行注册
import axios from &amp;#39;axios&amp;#39; app.config.globalProperties.$axios = axios 配置vue.config.js文件, 加入
devServer: { proxy:{ // 当我们的本地的请求 有/api的时候，就会代理我们的请求地址向另外一个服务器发出请求 // 这里的api 表示如果我们的请求地址有/api的时候,就出触发代理机制 // localhost:8888/api/abc =&amp;gt; 代理给另一个服务器 &amp;#39;/api&amp;#39;:{ // 目标路径,一般是后台服务器地址 target:&amp;#39;http://127.0.0.1:8000/&amp;#39;, // 允许跨域 changeOrigin: true, // 重写路径 pathRewrite: { // 重写路由 localhost:8888/api/login =&amp;gt; www.baidu.com/api/login &amp;#39;^/api&amp;#39;: &amp;#39;&amp;#39; // 假设我们想把 localhost:8888/api/login 变成www.</description></item><item><title>Mysecond Post</title><link>https://Dludora.github.io/Dludora_Blog/mysql/mysecond-post/</link><pubDate>Tue, 10 May 2022 11:33:45 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/mysql/mysecond-post/</guid><description>煞笔！</description></item><item><title>前后端分离1</title><link>https://Dludora.github.io/Dludora_Blog/softwareeg/myfirst-post/</link><pubDate>Tue, 10 May 2022 11:08:11 +0800</pubDate><guid>https://Dludora.github.io/Dludora_Blog/softwareeg/myfirst-post/</guid><description>1、前后端项目合并 后端项目 项目创建/运行 ​ 在前端项目同级命令行中打开终端，输入django-admin startproject 项目名称
​ cd进该目录，输入 python manage.py runserver，运行该项目，终端上出现链接
配置数据库 ​ 找到第一次创建出的文件夹下，找到settings.py文件，找到如下代码
DATABASES = { &amp;#39;default&amp;#39;: { &amp;#39;ENGINE&amp;#39;: &amp;#39;django.db.backends.sqlite3&amp;#39;, &amp;#39;NAME&amp;#39;: BASE_DIR / &amp;#39;db.sqlite3&amp;#39;, } } ​ 如果想要更换为自己的mysql数据库，可以参考以下设置进行更改
DATABASES = { &amp;#39;default&amp;#39;: { &amp;#39;ENGINE&amp;#39;: &amp;#39;django.db.backends.mysql&amp;#39;, &amp;#39;NAME&amp;#39;: &amp;#39;xxx&amp;#39;, # 数据库名称 &amp;#39;USER&amp;#39;: &amp;#39;root&amp;#39; # 连接数据库的用户名称 &amp;#39;PASSWORD&amp;#39;: &amp;#39;xxxx&amp;#39; # 用户密码 &amp;#39;HOST&amp;#39;: &amp;#39;127.0.0.1&amp;#39; # 访问的数据库的主机ip地址 &amp;#39;PORT&amp;#39;: &amp;#39;3306&amp;#39; # 默认mysql访问端口 } } 运行 python manage.py migrate
新建应用 ​ 再次在终端上输入python manage.py startapp xxx，创建出xxx应用
​ 找到第一次创建出的文件夹下，找到settings.</description></item><item><title>Archive</title><link>https://Dludora.github.io/Dludora_Blog/archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Dludora.github.io/Dludora_Blog/archive/</guid><description>archive</description></item></channel></rss>