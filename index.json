[{"content":"Java IO 流 一、文件操作 1、创建文件 new File(String pathname)\t根据路径构建一个File对象\nnew File(File parent, String child)\t根据父目录文件+子路径构造\nnew File(String parent, String child)\t根据父目录+子路径构建\n创建文件对象后,执行 file.createNewFile\n2、获取文件信息 file.getName()文件名字\nfile.getAbsolutePath()文件绝对路径\nfile.getParent文件父级目录\nfile.length()文件大小(字节)\nfile.exists() 文件/目录是否存在\nfile.isFile()是否是文件\nfile.isDirectory()是否是目录\n3、目录操作 file.delete()\t删除文件/目录\nfile.mkdir()\t创建一级目录\nfile.mkdirs()\t创建多级目录\n4、Java IO流原理及其分类 ​\tI/O是input/output的缩写，按照操作数据单位不同分为字节流，字符流。字节流操作二进制文件时更加适合，字符流操作文本文件更加适合。按照流的角色分为节点流、处理流、包装流。\n​\tIO流使用完毕后必须关闭!\n抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 4.1、InputStream 4.1.1 BufferedInputStream\t缓冲字节流 4.1.2 FileInputStream\t文件字节流 构造方法：\nFIleInputStream(File file) FIleInputStream(String filePath) FIleInputStream(FileDescription fdObj) 方法\nint read(byte[] b)读取一个字节的数据，返回实际读取的字节数。若达到文件末尾，返回-1。如果在其中加入byte[] b，则一次获取最多b.length字节的数据到字节数组。 可以把byte数组转成字符串new String(b, 0, readLen) 4.1.3 ObjectInputStream\t对象字节流 4.2、OutputStream 4.1.1 FileOutputStream FileOutputStream(filePath, append) 如果append是true而不是false时，以追加而不是覆盖的方式写入文件。\nwrite(byte[] b, off, len)会覆盖之前的文件，可以通过string.getBytes()把字符串转换为字节数组，输出到对应文件。 4.3 Reader 4.3.1 FileReader 与FileInputStream类似，读取单位变为字符。\n4.4 Writer ","permalink":"https://Dludora.github.io/Dludora_Blog/java/io/","summary":"Java IO 流 一、文件操作 1、创建文件 new File(String pathname)\t根据路径构建一个File对象\nnew File(File parent, String child)\t根据父目录文件+子路径构造\nnew File(String parent, String child)\t根据父目录+子路径构建\n创建文件对象后,执行 file.createNewFile\n2、获取文件信息 file.getName()文件名字\nfile.getAbsolutePath()文件绝对路径\nfile.getParent文件父级目录\nfile.length()文件大小(字节)\nfile.exists() 文件/目录是否存在\nfile.isFile()是否是文件\nfile.isDirectory()是否是目录\n3、目录操作 file.delete()\t删除文件/目录\nfile.mkdir()\t创建一级目录\nfile.mkdirs()\t创建多级目录\n4、Java IO流原理及其分类 ​\tI/O是input/output的缩写，按照操作数据单位不同分为字节流，字符流。字节流操作二进制文件时更加适合，字符流操作文本文件更加适合。按照流的角色分为节点流、处理流、包装流。\n​\tIO流使用完毕后必须关闭!\n抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 4.1、InputStream 4.1.1 BufferedInputStream\t缓冲字节流 4.1.2 FileInputStream\t文件字节流 构造方法：\nFIleInputStream(File file) FIleInputStream(String filePath) FIleInputStream(FileDescription fdObj) 方法\nint read(byte[] b)读取一个字节的数据，返回实际读取的字节数。若达到文件末尾，返回-1。如果在其中加入byte[] b，则一次获取最多b.","title":"Java IO流"},{"content":"Token 将token存储到store中，在store文件夹下新建user.js\n命令行输入npm i js-cookie\n","permalink":"https://Dludora.github.io/Dludora_Blog/softwareeg/my-third-post/","summary":"Token 将token存储到store中，在store文件夹下新建user.js\n命令行输入npm i js-cookie","title":"Vue解决登录问题"},{"content":"Vue 与 Markdown 交互 1. vue3 适配的 markdown编辑器 ​\t命令行输入npm i @kangc/v-md-editor@next -S安装 v-md-editor组件\n​\t在main.js中加入如下代码，即可通过v-md-editor模块进行使用markdown编辑器\n// 引入所有语言包 import hljs from \u0026#39;highlight.js\u0026#39; import VMdPreview from \u0026#39;@kangc/v-md-editor/lib/preview\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/style/preview.css\u0026#39;; import VMdEditor from \u0026#39;@kangc/v-md-editor/lib/codemirror-editor\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/style/codemirror-editor.css\u0026#39;; import githubTheme from \u0026#39;@kangc/v-md-editor/lib/theme/github.js\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/theme/style/github.css\u0026#39;; // emoji import createEmojiPlugin from \u0026#39;@kangc/v-md-editor/lib/plugins/emoji/index\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/plugins/emoji/emoji.css\u0026#39;; // 显示代码行数 import createLineNumbertPlugin from \u0026#39;@kangc/v-md-editor/lib/plugins/line-number/index\u0026#39;; // 快速复制 import createCopyCodePlugin from \u0026#39;@kangc/v-md-editor/lib/plugins/copy-code/index\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/plugins/copy-code/copy-code.css\u0026#39;; // codemirror 编辑器的相关资源 import Codemirror from \u0026#39;codemirror\u0026#39;; // mode import \u0026#39;codemirror/mode/markdown/markdown\u0026#39;; import \u0026#39;codemirror/mode/javascript/javascript\u0026#39;; import \u0026#39;codemirror/mode/css/css\u0026#39;; import \u0026#39;codemirror/mode/htmlmixed/htmlmixed\u0026#39;; import \u0026#39;codemirror/mode/vue/vue\u0026#39;; // edit import \u0026#39;codemirror/addon/edit/closebrackets\u0026#39;; import \u0026#39;codemirror/addon/edit/closetag\u0026#39;; import \u0026#39;codemirror/addon/edit/matchbrackets\u0026#39;; // placeholder import \u0026#39;codemirror/addon/display/placeholder\u0026#39;; // active-line import \u0026#39;codemirror/addon/selection/active-line\u0026#39;; // scrollbar import \u0026#39;codemirror/addon/scroll/simplescrollbars\u0026#39;; import \u0026#39;codemirror/addon/scroll/simplescrollbars.css\u0026#39;; // style import \u0026#39;codemirror/lib/codemirror.css\u0026#39;; VMdEditor.Codemirror = Codemirror; VMdEditor.use(githubTheme, { Hljs: hljs, }); VMdPreview.use(githubTheme, { Hljs: hljs, }); VMdPreview.use(createEmojiPlugin()); VMdPreview.use(createLineNumbertPlugin()); VMdPreview.use(createCopyCodePlugin()); app.use(VMdEditor); app.use(VMdPreview); 如果想要添加流程图功能\n在main.js中添加\n// 流程图 import createMermaidPlugin from \u0026#39;@kangc/v-md-editor/lib/plugins/mermaid/cdn\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/plugins/mermaid/mermaid.css\u0026#39;; VMdPreview.use(createMermaidPlugin()); 在index.html中添加\n\u0026lt;script src=\u0026#34;https://unpkg.com/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 在想要引入的页面中加入\n\u0026lt;v-md-editor v-model=\u0026#34;xxx\u0026#34; height=\u0026#34;600px\u0026#34;\u0026gt;\u0026lt;/v-md-editor\u0026gt; 2. 渲染markdown文件 需要提前安装的包 npm install vue-loader vue-template-compiler -D\nnpm install --save vue-markdown\nnpm install github-markdown-css\nnpm install highlight.js\nnpm install markdown-loader\n预览器使用 \u0026lt;v-md-preview :text=\u0026#34;blogForm.text\u0026#34;\u0026gt;\u0026lt;/v-md-preview\u0026gt; ","permalink":"https://Dludora.github.io/Dludora_Blog/softwareeg/my-second-post/","summary":"Vue 与 Markdown 交互 1. vue3 适配的 markdown编辑器 ​\t命令行输入npm i @kangc/v-md-editor@next -S安装 v-md-editor组件\n​\t在main.js中加入如下代码，即可通过v-md-editor模块进行使用markdown编辑器\n// 引入所有语言包 import hljs from \u0026#39;highlight.js\u0026#39; import VMdPreview from \u0026#39;@kangc/v-md-editor/lib/preview\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/style/preview.css\u0026#39;; import VMdEditor from \u0026#39;@kangc/v-md-editor/lib/codemirror-editor\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/style/codemirror-editor.css\u0026#39;; import githubTheme from \u0026#39;@kangc/v-md-editor/lib/theme/github.js\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/theme/style/github.css\u0026#39;; // emoji import createEmojiPlugin from \u0026#39;@kangc/v-md-editor/lib/plugins/emoji/index\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/plugins/emoji/emoji.css\u0026#39;; // 显示代码行数 import createLineNumbertPlugin from \u0026#39;@kangc/v-md-editor/lib/plugins/line-number/index\u0026#39;; // 快速复制 import createCopyCodePlugin from \u0026#39;@kangc/v-md-editor/lib/plugins/copy-code/index\u0026#39;; import \u0026#39;@kangc/v-md-editor/lib/plugins/copy-code/copy-code.css\u0026#39;; // codemirror 编辑器的相关资源 import Codemirror from \u0026#39;codemirror\u0026#39;; // mode import \u0026#39;codemirror/mode/markdown/markdown\u0026#39;; import \u0026#39;codemirror/mode/javascript/javascript\u0026#39;; import \u0026#39;codemirror/mode/css/css\u0026#39;; import \u0026#39;codemirror/mode/htmlmixed/htmlmixed\u0026#39;; import \u0026#39;codemirror/mode/vue/vue\u0026#39;; // edit import \u0026#39;codemirror/addon/edit/closebrackets\u0026#39;; import \u0026#39;codemirror/addon/edit/closetag\u0026#39;; import \u0026#39;codemirror/addon/edit/matchbrackets\u0026#39;; // placeholder import \u0026#39;codemirror/addon/display/placeholder\u0026#39;; // active-line import \u0026#39;codemirror/addon/selection/active-line\u0026#39;; // scrollbar import \u0026#39;codemirror/addon/scroll/simplescrollbars\u0026#39;; import \u0026#39;codemirror/addon/scroll/simplescrollbars.","title":"Vue 与 Markdown 交互"},{"content":"Vue-Django解决跨域 什么是跨域 跨域本质是浏览器基于同源策略的一种安全手段\n同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能\n所谓同源（即指在同一个域）具有以下三个相同点\n协议相同（protocol） 主机相同（host） 端口相同（port） 反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域\n一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。\n配置vue.config.js实现跨域 原理 ​\t将域名发送给本地的服务器(localhost:8080) ​\t再由本地的服务器去请求真正的服务器 ​\t因为请求是从服务器端发出的，所以就不存在跨域的问题 实现步骤 安装并引入axios 前端终端中输出 npm install axios -s安装axios\n在main.js中引入axios，在全局进行注册\nimport axios from \u0026#39;axios\u0026#39; app.config.globalProperties.$axios = axios 配置vue.config.js文件, 加入\ndevServer: { proxy:{ // 当我们的本地的请求 有/api的时候，就会代理我们的请求地址向另外一个服务器发出请求 // 这里的api 表示如果我们的请求地址有/api的时候,就出触发代理机制 // localhost:8888/api/abc =\u0026gt; 代理给另一个服务器 \u0026#39;/api\u0026#39;:{ // 目标路径,一般是后台服务器地址 target:\u0026#39;http://127.0.0.1:8000/\u0026#39;, // 允许跨域 changeOrigin: true, // 重写路径 pathRewrite: { // 重写路由 localhost:8888/api/login =\u0026gt; www.baidu.com/api/login \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; // 假设我们想把 localhost:8888/api/login 变成www.baidu.com/login 就需要这么做 } } } }, ","permalink":"https://Dludora.github.io/Dludora_Blog/softwareeg/%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F/","summary":"Vue-Django解决跨域 什么是跨域 跨域本质是浏览器基于同源策略的一种安全手段\n同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能\n所谓同源（即指在同一个域）具有以下三个相同点\n协议相同（protocol） 主机相同（host） 端口相同（port） 反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域\n一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。\n配置vue.config.js实现跨域 原理 ​\t将域名发送给本地的服务器(localhost:8080) ​\t再由本地的服务器去请求真正的服务器 ​\t因为请求是从服务器端发出的，所以就不存在跨域的问题 实现步骤 安装并引入axios 前端终端中输出 npm install axios -s安装axios\n在main.js中引入axios，在全局进行注册\nimport axios from \u0026#39;axios\u0026#39; app.config.globalProperties.$axios = axios 配置vue.config.js文件, 加入\ndevServer: { proxy:{ // 当我们的本地的请求 有/api的时候，就会代理我们的请求地址向另外一个服务器发出请求 // 这里的api 表示如果我们的请求地址有/api的时候,就出触发代理机制 // localhost:8888/api/abc =\u0026gt; 代理给另一个服务器 \u0026#39;/api\u0026#39;:{ // 目标路径,一般是后台服务器地址 target:\u0026#39;http://127.0.0.1:8000/\u0026#39;, // 允许跨域 changeOrigin: true, // 重写路径 pathRewrite: { // 重写路由 localhost:8888/api/login =\u0026gt; www.baidu.com/api/login \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; // 假设我们想把 localhost:8888/api/login 变成www.","title":"前端跨域"},{"content":" ","permalink":"https://Dludora.github.io/Dludora_Blog/vue/vue_basic1/","summary":" ","title":"Vue_basic1"},{"content":"第三方库 ","permalink":"https://Dludora.github.io/Dludora_Blog/vue/animation1/","summary":"第三方库 ","title":"Animation1"},{"content":"煞笔！\n","permalink":"https://Dludora.github.io/Dludora_Blog/mysql/mysecond-post/","summary":"煞笔！","title":"Mysecond Post"},{"content":"1、前后端项目合并 后端项目 项目创建/运行 ​\t在前端项目同级命令行中打开终端，输入django-admin startproject 项目名称\n​\tcd进该目录，输入 python manage.py runserver，运行该项目，终端上出现链接\n配置数据库 ​\t找到第一次创建出的文件夹下，找到settings.py文件，找到如下代码\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } ​\t如果想要更换为自己的mysql数据库，可以参考以下设置进行更改\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;xxx\u0026#39;,\t# 数据库名称 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;\t# 连接数据库的用户名称 \u0026#39;PASSWORD\u0026#39;: \u0026#39;xxxx\u0026#39;\t# 用户密码 \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;\t# 访问的数据库的主机ip地址 \u0026#39;PORT\u0026#39;: \u0026#39;3306\u0026#39;\t# 默认mysql访问端口 } } 运行 python manage.py migrate\n新建应用 ​\t再次在终端上输入python manage.py startapp xxx，创建出xxx应用\n​\t找到第一次创建出的文件夹下，找到settings.py文件，找到如下代码\nINSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;backend.apps.BackendConfig\u0026#39;, ] ​\t把新建的应用添加进去,修改如下\nINSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;backend.apps.BackendConfig\u0026#39;, \u0026#39;xxx.apps.XxxConfig\u0026#39;, ] 在models.py文件中添加好自己想要的内容后，运行python manage.py makemigrations, python manage.py migrate\n超级管理员 在终端中，输入python manage.py createsuperuser后，按照提示创建超级管理员账号\n在服务端口后加/admin，即可进入超级管理员界面，如果想要在该界面管理新建出的xxx应用，则修改改应用目录下的admin.py文件\nadmin.py文件\nfrom django.contrib import admin from .models import Author # Register your models here. class AuthorAdmin(admin.ModelAdmin): list_display = [\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;email\u0026#39;] admin.site.register(Author, AuthorAdmin) models.py文件\nfrom django.db import models class Author(models.Model): # Author表项，含用户名和密码，均为字符串属性，并设置最大长度 username = models.CharField(max_length=50,primary_key=False) password = models.CharField(max_length=20) email = models.EmailField() 安装def-rest-framework 终端依次输入指令 pip install djangorestframework\npip install markdown\npip install django-filter\n配置drf settings.py文件 引入app INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;rest_framework\u0026#39;,\t// 写在所有自定义模块之上 \u0026#39;backend.apps.BackendConfig\u0026#39;, ] 引入drf 放在DATA_BASE以下\nREST_FRAMEWORK = { \u0026#39;DEFAULT_PERMISSION_CLASSES\u0026#39;: [ \u0026#39;rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly\u0026#39; ] } 实现cors跨域 命令行输入pip install django-cors-headers\n在settings.py 中的INSTALED_APPS中引入corsheaders , MIDDLEWARE中的第三位引入corsheaders.middleware.CorsMiddleware\n文件最下方加入\nCORS_ORIGIN_WHITELIST = ( \u0026#39;http://127.0.0.1:8080\u0026#39;, \u0026#39;http://localhost:8080\u0026#39;, ) CORS_ALLOW_CREDENTIALS = True # 指明在跨域访问中，后端是否支持对cookie的操作。 CORS_ALLOW_METHODS = ( \u0026#39;DELETE\u0026#39;, \u0026#39;GET\u0026#39;, \u0026#39;OPTIONS\u0026#39;, \u0026#39;PATCH\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;PUT\u0026#39;, \u0026#39;VIEW\u0026#39;, ) CORS_ALLOW_HEADERS = ( \u0026#39;XMLHttpRequest\u0026#39;, \u0026#39;X_FILENAME\u0026#39;, \u0026#39;accept-encoding\u0026#39;, \u0026#39;authorization\u0026#39;, \u0026#39;content-type\u0026#39;, \u0026#39;dnt\u0026#39;, \u0026#39;origin\u0026#39;, \u0026#39;user-agent\u0026#39;, \u0026#39;x-csrftoken\u0026#39;, \u0026#39;x-requested-with\u0026#39;, \u0026#39;Pragma\u0026#39;, ) ","permalink":"https://Dludora.github.io/Dludora_Blog/softwareeg/myfirst-post/","summary":"1、前后端项目合并 后端项目 项目创建/运行 ​\t在前端项目同级命令行中打开终端，输入django-admin startproject 项目名称\n​\tcd进该目录，输入 python manage.py runserver，运行该项目，终端上出现链接\n配置数据库 ​\t找到第一次创建出的文件夹下，找到settings.py文件，找到如下代码\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } ​\t如果想要更换为自己的mysql数据库，可以参考以下设置进行更改\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;xxx\u0026#39;,\t# 数据库名称 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;\t# 连接数据库的用户名称 \u0026#39;PASSWORD\u0026#39;: \u0026#39;xxxx\u0026#39;\t# 用户密码 \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;\t# 访问的数据库的主机ip地址 \u0026#39;PORT\u0026#39;: \u0026#39;3306\u0026#39;\t# 默认mysql访问端口 } } 运行 python manage.py migrate\n新建应用 ​\t再次在终端上输入python manage.py startapp xxx，创建出xxx应用\n​\t找到第一次创建出的文件夹下，找到settings.","title":"前后端分离1"},{"content":"","permalink":"https://Dludora.github.io/Dludora_Blog/archive/","summary":"archive","title":"Archive"}]