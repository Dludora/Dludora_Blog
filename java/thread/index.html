<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>多线程 | Dludora's Blog</title><meta name=keywords content><meta name=description content="多线程 程序：我们写的代码 进程：运行中的程序，是程序的一个执行过程 一、继承Thread类（重写 run 方法） ​	当一个类继承了Thread类，该类就可以当作线程使用。我们会重写run方法，写上自己的业务代码。run Thread类实现了Runnable接口中的run方法。通过start方法启动线程。
​	使用JConsole监控线程执行情况，并画出程序示意图。(命令行输入jconsole)
public class Thread01 { public static void main(String[] args) throws InterruptedException { // 创建Cat对象，可以当作线程使用 Cat cat = new Cat(); cat.start(); // 启动线程->最终会执行cat的run方法 // 当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行 System.out.println(&#34;主线程继续执行&#34; + Thread.currentThread().getName()); for (int i = 0; i < 10; i++) { System.out.println(&#34;主线程 i = &#34;+ i); // 让主线程休眠 Thread.sleep(1000); } } } class Cat extends Thread { int times = 0; @Override public void run() { while (true) { // 该线程每隔一秒，在控制台输出&#34;喵喵，我是小猫咪&#34; System."><meta name=author content="codecat"><link rel=canonical href=https://Dludora.github.io/Dludora_Blog/java/thread/><link crossorigin=anonymous href=/Dludora_Blog/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/Dludora_Blog/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://Dludora.github.io/Dludora_Blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Dludora.github.io/Dludora_Blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Dludora.github.io/Dludora_Blog/favicon-32x32.png><link rel=apple-touch-icon href=https://Dludora.github.io/Dludora_Blog/apple-touch-icon.png><link rel=mask-icon href=https://Dludora.github.io/Dludora_Blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="多线程"><meta property="og:description" content="多线程 程序：我们写的代码 进程：运行中的程序，是程序的一个执行过程 一、继承Thread类（重写 run 方法） ​	当一个类继承了Thread类，该类就可以当作线程使用。我们会重写run方法，写上自己的业务代码。run Thread类实现了Runnable接口中的run方法。通过start方法启动线程。
​	使用JConsole监控线程执行情况，并画出程序示意图。(命令行输入jconsole)
public class Thread01 { public static void main(String[] args) throws InterruptedException { // 创建Cat对象，可以当作线程使用 Cat cat = new Cat(); cat.start(); // 启动线程->最终会执行cat的run方法 // 当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行 System.out.println(&#34;主线程继续执行&#34; + Thread.currentThread().getName()); for (int i = 0; i < 10; i++) { System.out.println(&#34;主线程 i = &#34;+ i); // 让主线程休眠 Thread.sleep(1000); } } } class Cat extends Thread { int times = 0; @Override public void run() { while (true) { // 该线程每隔一秒，在控制台输出&#34;喵喵，我是小猫咪&#34; System."><meta property="og:type" content="article"><meta property="og:url" content="https://Dludora.github.io/Dludora_Blog/java/thread/"><meta property="article:section" content="Java"><meta property="article:published_time" content="2022-06-30T20:38:02+08:00"><meta property="article:modified_time" content="2022-06-30T20:38:02+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="多线程"><meta name=twitter:description content="多线程 程序：我们写的代码 进程：运行中的程序，是程序的一个执行过程 一、继承Thread类（重写 run 方法） ​	当一个类继承了Thread类，该类就可以当作线程使用。我们会重写run方法，写上自己的业务代码。run Thread类实现了Runnable接口中的run方法。通过start方法启动线程。
​	使用JConsole监控线程执行情况，并画出程序示意图。(命令行输入jconsole)
public class Thread01 { public static void main(String[] args) throws InterruptedException { // 创建Cat对象，可以当作线程使用 Cat cat = new Cat(); cat.start(); // 启动线程->最终会执行cat的run方法 // 当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行 System.out.println(&#34;主线程继续执行&#34; + Thread.currentThread().getName()); for (int i = 0; i < 10; i++) { System.out.println(&#34;主线程 i = &#34;+ i); // 让主线程休眠 Thread.sleep(1000); } } } class Cat extends Thread { int times = 0; @Override public void run() { while (true) { // 该线程每隔一秒，在控制台输出&#34;喵喵，我是小猫咪&#34; System."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Javae","item":"https://Dludora.github.io/Dludora_Blog/java/"},{"@type":"ListItem","position":3,"name":"多线程","item":"https://Dludora.github.io/Dludora_Blog/java/thread/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"多线程","name":"多线程","description":"多线程 程序：我们写的代码 进程：运行中的程序，是程序的一个执行过程 一、继承Thread类（重写 run 方法） ​\t当一个类继承了Thread类，该类就可以当作线程使用。我们会重写run方法，写上自己的业务代码。run Thread类实现了Runnable接口中的run方法。通过start方法启动线程。\n​\t使用JConsole监控线程执行情况，并画出程序示意图。(命令行输入jconsole)\npublic class Thread01 { public static void main(String[] args) throws InterruptedException { // 创建Cat对象，可以当作线程使用 Cat cat = new Cat(); cat.start(); // 启动线程-\u0026gt;最终会执行cat的run方法 // 当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行 System.out.println(\u0026#34;主线程继续执行\u0026#34; + Thread.currentThread().getName()); for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;主线程 i = \u0026#34;+ i); // 让主线程休眠 Thread.sleep(1000); } } } class Cat extends Thread { int times = 0; @Override public void run() { while (true) { // 该线程每隔一秒，在控制台输出\u0026#34;喵喵，我是小猫咪\u0026#34; System.","keywords":[],"articleBody":"多线程 程序：我们写的代码 进程：运行中的程序，是程序的一个执行过程 一、继承Thread类（重写 run 方法） ​\t当一个类继承了Thread类，该类就可以当作线程使用。我们会重写run方法，写上自己的业务代码。run Thread类实现了Runnable接口中的run方法。通过start方法启动线程。\n​\t使用JConsole监控线程执行情况，并画出程序示意图。(命令行输入jconsole)\npublic class Thread01 { public static void main(String[] args) throws InterruptedException { // 创建Cat对象，可以当作线程使用 Cat cat = new Cat(); cat.start(); // 启动线程-\u003e最终会执行cat的run方法 // 当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行 System.out.println(\"主线程继续执行\" + Thread.currentThread().getName()); for (int i = 0; i \u003c 10; i++) { System.out.println(\"主线程 i = \"+ i); // 让主线程休眠 Thread.sleep(1000); } } } class Cat extends Thread { int times = 0; @Override public void run() { while (true) { // 该线程每隔一秒，在控制台输出\"喵喵，我是小猫咪\" System.out.println(\"喵喵，我是小猫咪\" + (++times) + \" 线程名=\" + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (times == 8) { break; } } } } 二、实现Runnable接口 说明\nJava是单继承的，在某些情况下一个类可能已经继承了某个父类，这时无法再继承Thread类方法来创建进程。 可以通过实现Runnable接口来创建线程 public class Thread02 { public static void main(String[] args) { Dog dog = new Dog(); // 这里不能直接 调用start()方法 Thread thread = new Thread(dog); thread.start(); } } class Dog implements Runnable { int count = 0; @Override public void run() { while (true) { System.out.println(\"小狗汪汪叫..hi\" + (++count) + Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 三、线程方法 setName、getName、start、run、setPriority、getPriority、sleep、interrupt\n1、线程礼让（yield） ​\t让出CPU，让其他线程执行，但礼让的时间不确定，也不一定礼让成功（资源充足时）。\n2、线程插队（join） 插队的线程一旦插队成功，则肯定先执行完插入的线程的所有任务。\npackage threaduse; public class Thread03 { public static void main(String[] args) { T1 t1 = new T1(); t1.start(); for (int i = 1; i \u003c= 20; i++) { try { Thread.sleep(1000); System.out.println(\"主线程 吃了\" + i + \" 个包子\"); if (i == 5) { System.out.println(\"主线程让 子线程 先全部吃完\"); t1.join(); // 相当于让t2线程先执行完毕。 System.out.println(\"子线程 全部吃完，主线程接着吃\"); } } catch (InterruptedException e) { e.printStackTrace(); } } } } class T1 extends Thread { @Override public void run() { for (int i = 1; i \u003c= 20; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"子线程 吃了\" + i + \" 个包子\"); } } } 3、用户线程和守护线程 用户线程：也叫哦工作线程，当线程的任务执行完或通知方式结束 守护线程：一般是为工作线程服务，当所有用户线程结束，守护线程自动结束 常见守护线程：垃圾回收机制。 设置某一线程为守护线程，在线程开始之前执行语句：Thread.setDaemon(true)\n四、锁 解决超卖问题\n1、线程同步机制 在多线程编程，一些敏感数据不允许被多个线程同时访问，使用同步访问计数，保证数据在任何同一时刻，最多有一个线程访问，保证数据的完整性。 当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，知道该线程完成操作。 2、同步方法 2.1 同步 synchronized(对象) {\t// 得到对象的锁 // 需要被同步的代码 } public synchronized void m(String name) { // 需要被同步的代码 } 2.2 互斥锁 ","wordCount":"311","inLanguage":"en","datePublished":"2022-06-30T20:38:02+08:00","dateModified":"2022-06-30T20:38:02+08:00","author":{"@type":"Person","name":"codecat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://Dludora.github.io/Dludora_Blog/java/thread/"},"publisher":{"@type":"Organization","name":"Dludora's Blog","logo":{"@type":"ImageObject","url":"https://Dludora.github.io/Dludora_Blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Dludora.github.io/Dludora_Blog accesskey=h title="Dludora's Blog (Alt + H)">Dludora's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://Dludora.github.io/Dludora_Blog/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://github.com/Dludora/Dludora_Blog title=Github><span>Github</span></a></li><li><a href=https://Dludora.github.io/Dludora_Blog/archive title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Dludora.github.io/Dludora_Blog>Home</a>&nbsp;»&nbsp;<a href=https://Dludora.github.io/Dludora_Blog/java/>Javae</a></div><h1 class=post-title>多线程</h1><div class=post-meta><span title='2022-06-30 20:38:02 +0800 +0800'>June 30, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;codecat&nbsp;|&nbsp;<a href=https://github.com/Dludora/Dludora_Blog/tree/main/content/Java/Thread.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=多线程>多线程</a><ul><li><a href=#%e4%b8%80%e7%bb%a7%e6%89%bfthread%e7%b1%bb%e9%87%8d%e5%86%99-run-%e6%96%b9%e6%b3%95 aria-label="一、继承Thread类（重写 run 方法）">一、继承Thread类（重写 run 方法）</a></li><li><a href=#%e4%ba%8c%e5%ae%9e%e7%8e%b0runnable%e6%8e%a5%e5%8f%a3 aria-label=二、实现Runnable接口>二、实现Runnable接口</a></li><li><a href=#%e4%b8%89%e7%ba%bf%e7%a8%8b%e6%96%b9%e6%b3%95 aria-label=三、线程方法>三、线程方法</a><ul><li><a href=#1%e7%ba%bf%e7%a8%8b%e7%a4%bc%e8%ae%a9yield aria-label=1、线程礼让（yield）>1、线程礼让（yield）</a></li><li><a href=#2%e7%ba%bf%e7%a8%8b%e6%8f%92%e9%98%9fjoin aria-label=2、线程插队（join）>2、线程插队（join）</a></li><li><a href=#3%e7%94%a8%e6%88%b7%e7%ba%bf%e7%a8%8b%e5%92%8c%e5%ae%88%e6%8a%a4%e7%ba%bf%e7%a8%8b aria-label=3、用户线程和守护线程>3、用户线程和守护线程</a></li></ul></li><li><a href=#%e5%9b%9b%e9%94%81 aria-label=四、锁>四、锁</a><ul><li><a href=#1%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6 aria-label=1、线程同步机制>1、线程同步机制</a></li><li><a href=#2%e5%90%8c%e6%ad%a5%e6%96%b9%e6%b3%95 aria-label=2、同步方法>2、同步方法</a><ul><li><a href=#21-%e5%90%8c%e6%ad%a5 aria-label="2.1 同步">2.1 同步</a></li><li><a href=#22-%e4%ba%92%e6%96%a5%e9%94%81 aria-label="2.2 互斥锁">2.2 互斥锁</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=多线程>多线程<a hidden class=anchor aria-hidden=true href=#多线程>#</a></h1><ul><li>程序：我们写的代码</li><li>进程：运行中的程序，是程序的一个执行过程</li></ul><h2 id=一继承thread类重写-run-方法>一、继承Thread类（重写 run 方法）<a hidden class=anchor aria-hidden=true href=#一继承thread类重写-run-方法>#</a></h2><p>​ 当一个类继承了<code>Thread</code>类，该类就可以当作线程使用。我们会重写<code>run</code>方法，写上自己的业务代码。<code>run Thread</code>类实现了<code>Runnable</code>接口中的<code>run</code>方法。通过<code>start</code>方法启动线程。</p><p>​ 使用<code>JConsole</code>监控线程执行情况，并画出程序示意图。(命令行输入<code>jconsole</code>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Thread01</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建Cat对象，可以当作线程使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Cat cat <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Cat<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        cat<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>    <span style=color:#75715e>// 启动线程-&gt;最终会执行cat的run方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 当main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;主线程继续执行&#34;</span> <span style=color:#f92672>+</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> 10<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;主线程 i = &#34;</span><span style=color:#f92672>+</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 让主线程休眠
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>1000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cat</span> <span style=color:#66d9ef>extends</span> Thread <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> times <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 该线程每隔一秒，在控制台输出&#34;喵喵，我是小猫咪&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;喵喵，我是小猫咪&#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(++</span>times<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 线程名=&#34;</span> <span style=color:#f92672>+</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>1000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>times <span style=color:#f92672>==</span> 8<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=二实现runnable接口>二、实现Runnable接口<a hidden class=anchor aria-hidden=true href=#二实现runnable接口>#</a></h2><p><strong>说明</strong></p><ul><li>Java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时无法再继承Thread类方法来创建进程。</li><li>可以通过实现<code>Runnable</code>接口来创建线程</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Thread02</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Dog dog <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Dog<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里不能直接 调用start()方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span>dog<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        thread<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> <span style=color:#66d9ef>implements</span> Runnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;小狗汪汪叫..hi&#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(++</span>count<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>1000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=三线程方法>三、线程方法<a hidden class=anchor aria-hidden=true href=#三线程方法>#</a></h2><p><code>setName</code>、<code>getName</code>、<code>start</code>、<code>run</code>、<code>setPriority</code>、<code>getPriority</code>、<code>sleep</code>、<code>interrupt</code></p><h3 id=1线程礼让yield>1、线程礼让（yield）<a hidden class=anchor aria-hidden=true href=#1线程礼让yield>#</a></h3><p>​ 让出CPU，让其他线程执行，但礼让的时间不确定，也不一定礼让成功（资源充足时）。</p><h3 id=2线程插队join>2、线程插队（join）<a hidden class=anchor aria-hidden=true href=#2线程插队join>#</a></h3><p>插队的线程一旦插队成功，则肯定先执行完插入的线程的所有任务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> threaduse<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Thread03</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        T1 t1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> T1<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        t1<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> 20<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>1000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;主线程 吃了&#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 个包子&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>i <span style=color:#f92672>==</span> 5<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;主线程让 子线程 先全部吃完&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    t1<span style=color:#f92672>.</span><span style=color:#a6e22e>join</span><span style=color:#f92672>();</span>      <span style=color:#75715e>// 相当于让t2线程先执行完毕。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;子线程 全部吃完，主线程接着吃&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T1</span> <span style=color:#66d9ef>extends</span> Thread <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;=</span> 20<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span>1000<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;子线程 吃了&#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 个包子&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=3用户线程和守护线程>3、用户线程和守护线程<a hidden class=anchor aria-hidden=true href=#3用户线程和守护线程>#</a></h3><ol><li>用户线程：也叫哦工作线程，当线程的任务执行完或通知方式结束</li><li>守护线程：一般是为工作线程服务，当所有用户线程结束，守护线程自动结束</li><li>常见守护线程：垃圾回收机制。</li></ol><p><strong>设置某一线程为守护线程</strong>，在线程开始之前执行语句：<code>Thread.setDaemon(true)</code></p><h2 id=四锁>四、锁<a hidden class=anchor aria-hidden=true href=#四锁>#</a></h2><p>解决<strong>超卖问题</strong></p><h3 id=1线程同步机制>1、线程同步机制<a hidden class=anchor aria-hidden=true href=#1线程同步机制>#</a></h3><ol><li>在多线程编程，一些敏感数据不允许被多个线程同时访问，使用同步访问计数，保证数据在任何同一时刻，最多有一个线程访问，保证数据的完整性。</li><li>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，知道该线程完成操作。</li></ol><h3 id=2同步方法>2、同步方法<a hidden class=anchor aria-hidden=true href=#2同步方法>#</a></h3><h4 id=21-同步>2.1 同步<a hidden class=anchor aria-hidden=true href=#21-同步>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>对象<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>	<span style=color:#75715e>// 得到对象的锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 需要被同步的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>m</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 需要被同步的代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=22-互斥锁>2.2 互斥锁<a hidden class=anchor aria-hidden=true href=#22-互斥锁>#</a></h4></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://Dludora.github.io/Dludora_Blog>Dludora's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>